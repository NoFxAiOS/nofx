package decision

import (
	"encoding/json"
	"fmt"
	"log"
	"nofx/market"
	"nofx/mcp"
	"nofx/pool"
	"regexp"
	"strings"
	"time"
)

// é¢„ç¼–è¯‘æ­£åˆ™è¡¨è¾¾å¼ï¼ˆæ€§èƒ½ä¼˜åŒ–ï¼šé¿å…æ¯æ¬¡è°ƒç”¨æ—¶é‡æ–°ç¼–è¯‘ï¼‰
var (
	// âœ… å®‰å…¨çš„æ­£å‰‡ï¼šç²¾ç¢ºåŒ¹é… ```json ä»£ç¢¼å¡Š
	// ä½¿ç”¨åå¼•è™Ÿ + æ‹¼æ¥é¿å…è½‰ç¾©å•é¡Œ
	reJSONFence      = regexp.MustCompile(`(?is)` + "```json\\s*(\\[\\s*\\{.*?\\}\\s*\\])\\s*```")
	reJSONArray      = regexp.MustCompile(`(?is)\[\s*\{.*?\}\s*\]`)
	reArrayHead      = regexp.MustCompile(`^\[\s*\{`)
	reArrayOpenSpace = regexp.MustCompile(`^\[\s+\{`)
	reInvisibleRunes = regexp.MustCompile("[\u200B\u200C\u200D\uFEFF]")
)

// PositionInfo æŒä»“ä¿¡æ¯
type PositionInfo struct {
	Symbol           string  `json:"symbol"`
	Side             string  `json:"side"` // "long" or "short"
	EntryPrice       float64 `json:"entry_price"`
	MarkPrice        float64 `json:"mark_price"`
	Quantity         float64 `json:"quantity"`
	Leverage         int     `json:"leverage"`
	UnrealizedPnL    float64 `json:"unrealized_pnl"`
	UnrealizedPnLPct float64 `json:"unrealized_pnl_pct"`
	LiquidationPrice float64 `json:"liquidation_price"`
	MarginUsed       float64 `json:"margin_used"`
	UpdateTime       int64   `json:"update_time"` // æŒä»“æ›´æ–°æ—¶é—´æˆ³ï¼ˆæ¯«ç§’ï¼‰
}

// AccountInfo è´¦æˆ·ä¿¡æ¯
type AccountInfo struct {
	TotalEquity      float64 `json:"total_equity"`      // è´¦æˆ·å‡€å€¼
	AvailableBalance float64 `json:"available_balance"` // å¯ç”¨ä½™é¢
	TotalPnL         float64 `json:"total_pnl"`         // æ€»ç›ˆäº
	TotalPnLPct      float64 `json:"total_pnl_pct"`     // æ€»ç›ˆäºç™¾åˆ†æ¯”
	MarginUsed       float64 `json:"margin_used"`       // å·²ç”¨ä¿è¯é‡‘
	MarginUsedPct    float64 `json:"margin_used_pct"`   // ä¿è¯é‡‘ä½¿ç”¨ç‡
	PositionCount    int     `json:"position_count"`    // æŒä»“æ•°é‡
}

// CandidateCoin å€™é€‰å¸ç§ï¼ˆæ¥è‡ªå¸ç§æ± ï¼‰
type CandidateCoin struct {
	Symbol  string   `json:"symbol"`
	Sources []string `json:"sources"` // æ¥æº: "ai500" å’Œ/æˆ– "oi_top"
}

// OITopData æŒä»“é‡å¢é•¿Topæ•°æ®ï¼ˆç”¨äºAIå†³ç­–å‚è€ƒï¼‰
type OITopData struct {
	Rank              int     // OI Topæ’å
	OIDeltaPercent    float64 // æŒä»“é‡å˜åŒ–ç™¾åˆ†æ¯”ï¼ˆ1å°æ—¶ï¼‰
	OIDeltaValue      float64 // æŒä»“é‡å˜åŒ–ä»·å€¼
	PriceDeltaPercent float64 // ä»·æ ¼å˜åŒ–ç™¾åˆ†æ¯”
	NetLong           float64 // å‡€å¤šä»“
	NetShort          float64 // å‡€ç©ºä»“
}

// Context äº¤æ˜“ä¸Šä¸‹æ–‡ï¼ˆä¼ é€’ç»™AIçš„å®Œæ•´ä¿¡æ¯ï¼‰
type Context struct {
	CurrentTime     string                  `json:"current_time"`
	RuntimeMinutes  int                     `json:"runtime_minutes"`
	CallCount       int                     `json:"call_count"`
	Account         AccountInfo             `json:"account"`
	Positions       []PositionInfo          `json:"positions"`
	MaxPositions    int                     `json:"max_positions"`
	CandidateCoins  []CandidateCoin         `json:"candidate_coins"`
	MarketDataMap   map[string]*market.Data `json:"-"` // ä¸åºåˆ—åŒ–ï¼Œä½†å†…éƒ¨ä½¿ç”¨
	OITopDataMap    map[string]*OITopData   `json:"-"` // OI Topæ•°æ®æ˜ å°„
	Performance     interface{}             `json:"-"` // å†å²è¡¨ç°åˆ†æï¼ˆlogger.PerformanceAnalysisï¼‰
	BTCETHLeverage  int                     `json:"-"` // BTC/ETHæ æ†å€æ•°ï¼ˆä»é…ç½®è¯»å–ï¼‰
	AltcoinLeverage int                     `json:"-"` // å±±å¯¨å¸æ æ†å€æ•°ï¼ˆä»é…ç½®è¯»å–ï¼‰
}

// Decision AIçš„äº¤æ˜“å†³ç­–
type Decision struct {
	Symbol string `json:"symbol"`
	Action string `json:"action"` // "open_long", "open_short", "close_long", "close_short", "update_stop_loss", "update_take_profit", "partial_close", "hold", "wait"

	// å¼€ä»“å‚æ•°
	Leverage        int     `json:"leverage,omitempty"`
	PositionSizeUSD float64 `json:"position_size_usd,omitempty"`
	StopLoss        float64 `json:"stop_loss,omitempty"`
	TakeProfit      float64 `json:"take_profit,omitempty"`

	// è°ƒæ•´å‚æ•°ï¼ˆæ–°å¢ï¼‰
	NewStopLoss     float64 `json:"new_stop_loss,omitempty"`    // ç”¨äº update_stop_loss
	NewTakeProfit   float64 `json:"new_take_profit,omitempty"`  // ç”¨äº update_take_profit
	ClosePercentage float64 `json:"close_percentage,omitempty"` // ç”¨äº partial_close (0-100)

	// é€šç”¨å‚æ•°
	Confidence int     `json:"confidence,omitempty"` // ä¿¡å¿ƒåº¦ (0-100)
	RiskUSD    float64 `json:"risk_usd,omitempty"`   // æœ€å¤§ç¾å…ƒé£é™©
	Reasoning  string  `json:"reasoning"`
}

// FullDecision AIçš„å®Œæ•´å†³ç­–ï¼ˆåŒ…å«æ€ç»´é“¾ï¼‰
type FullDecision struct {
	SystemPrompt string     `json:"system_prompt"` // ç³»ç»Ÿæç¤ºè¯ï¼ˆå‘é€ç»™AIçš„ç³»ç»Ÿpromptï¼‰
	UserPrompt   string     `json:"user_prompt"`   // å‘é€ç»™AIçš„è¾“å…¥prompt
	CoTTrace     string     `json:"cot_trace"`     // æ€ç»´é“¾åˆ†æï¼ˆAIè¾“å‡ºï¼‰
	Decisions    []Decision `json:"decisions"`     // å…·ä½“å†³ç­–åˆ—è¡¨
	Timestamp    time.Time  `json:"timestamp"`
}

// GetFullDecision è·å–AIçš„å®Œæ•´äº¤æ˜“å†³ç­–ï¼ˆæ‰¹é‡åˆ†ææ‰€æœ‰å¸ç§å’ŒæŒä»“ï¼‰
func GetFullDecision(ctx *Context, mcpClient *mcp.Client) (*FullDecision, error) {
	return GetFullDecisionWithCustomPrompt(ctx, mcpClient, "", false, "")
}

// GetFullDecisionWithCustomPrompt è·å–AIçš„å®Œæ•´äº¤æ˜“å†³ç­–ï¼ˆæ”¯æŒè‡ªå®šä¹‰promptå’Œæ¨¡æ¿é€‰æ‹©ï¼‰
func GetFullDecisionWithCustomPrompt(ctx *Context, mcpClient *mcp.Client, customPrompt string, overrideBase bool, templateName string) (*FullDecision, error) {
	// 1. ä¸ºæ‰€æœ‰å¸ç§è·å–å¸‚åœºæ•°æ®
	if err := fetchMarketDataForContext(ctx); err != nil {
		return nil, fmt.Errorf("è·å–å¸‚åœºæ•°æ®å¤±è´¥: %w", err)
	}

	// 2. æ„å»º System Promptï¼ˆå›ºå®šè§„åˆ™ï¼‰å’Œ User Promptï¼ˆåŠ¨æ€æ•°æ®ï¼‰
	systemPrompt := buildSystemPromptWithCustom(ctx.Account.TotalEquity, ctx.Account.AvailableBalance, ctx.BTCETHLeverage, ctx.AltcoinLeverage, ctx.MaxPositions, customPrompt, overrideBase, templateName)
	userPrompt := buildUserPrompt(ctx)

	// 3. è°ƒç”¨AI APIï¼ˆä½¿ç”¨ system + user promptï¼‰
	aiResponse, err := mcpClient.CallWithMessages(systemPrompt, userPrompt)
	if err != nil {
		return nil, fmt.Errorf("è°ƒç”¨AI APIå¤±è´¥: %w", err)
	}

	// 4. è§£æAIå“åº”
	decision, err := parseFullDecisionResponse(aiResponse, ctx)

	decision.Timestamp = time.Now()
	decision.SystemPrompt = systemPrompt // ä¿å­˜ç³»ç»Ÿprompt
	decision.UserPrompt = userPrompt     // ä¿å­˜è¾“å…¥prompt

	return decision, err
}

// fetchMarketDataForContext ä¸ºä¸Šä¸‹æ–‡ä¸­çš„æ‰€æœ‰å¸ç§è·å–å¸‚åœºæ•°æ®å’ŒOIæ•°æ®
func fetchMarketDataForContext(ctx *Context) error {
	ctx.MarketDataMap = make(map[string]*market.Data)
	ctx.OITopDataMap = make(map[string]*OITopData)

	// æ”¶é›†æ‰€æœ‰éœ€è¦è·å–æ•°æ®çš„å¸ç§
	symbolSet := make(map[string]bool)

	// 1. ä¼˜å…ˆè·å–æŒä»“å¸ç§çš„æ•°æ®ï¼ˆè¿™æ˜¯å¿…é¡»çš„ï¼‰
	for _, pos := range ctx.Positions {
		symbolSet[pos.Symbol] = true
	}

	// 2. å€™é€‰å¸ç§æ•°é‡æ ¹æ®è´¦æˆ·çŠ¶æ€åŠ¨æ€è°ƒæ•´
	for _, coin := range ctx.CandidateCoins {
		symbolSet[coin.Symbol] = true
	}

	// å¹¶å‘è·å–å¸‚åœºæ•°æ®
	// æŒä»“å¸ç§é›†åˆï¼ˆç”¨äºåˆ¤æ–­æ˜¯å¦è·³è¿‡OIæ£€æŸ¥ï¼‰
	positionSymbols := make(map[string]bool)
	for _, pos := range ctx.Positions {
		positionSymbols[pos.Symbol] = true
	}

	for symbol := range symbolSet {
		data, err := market.Get(symbol)
		if err != nil {
			// å•ä¸ªå¸ç§å¤±è´¥ä¸å½±å“æ•´ä½“ï¼Œåªè®°å½•é”™è¯¯
			continue
		}

		// âš ï¸ æµåŠ¨æ€§è¿‡æ»¤ï¼šæŒä»“ä»·å€¼ä½äºé˜ˆå€¼çš„å¸ç§ä¸åšï¼ˆå¤šç©ºéƒ½ä¸åšï¼‰
		// æŒä»“ä»·å€¼ = æŒä»“é‡ Ã— å½“å‰ä»·æ ¼
		// ä½†ç°æœ‰æŒä»“å¿…é¡»ä¿ç•™ï¼ˆéœ€è¦å†³ç­–æ˜¯å¦å¹³ä»“ï¼‰
		// ğŸ’¡ OI é–€æª»é…ç½®ï¼šç”¨æˆ¶å¯æ ¹æ“šé¢¨éšªåå¥½èª¿æ•´
		const minOIThresholdMillions = 15.0 // å¯èª¿æ•´ï¼š15M(ä¿å®ˆ) / 10M(å¹³è¡¡) / 8M(å¯¬é¬†) / 5M(æ¿€é€²)

		isExistingPosition := positionSymbols[symbol]
		if !isExistingPosition && data.OpenInterest != nil && data.CurrentPrice > 0 {
			// è®¡ç®—æŒä»“ä»·å€¼ï¼ˆUSDï¼‰= æŒä»“é‡ Ã— å½“å‰ä»·æ ¼
			oiValue := data.OpenInterest.Latest * data.CurrentPrice
			oiValueInMillions := oiValue / 1_000_000 // è½¬æ¢ä¸ºç™¾ä¸‡ç¾å…ƒå•ä½
			if oiValueInMillions < minOIThresholdMillions {
				log.Printf("âš ï¸  %s æŒä»“ä»·å€¼è¿‡ä½(%.2fM USD < %.1fM)ï¼Œè·³è¿‡æ­¤å¸ç§ [æŒä»“é‡:%.0f Ã— ä»·æ ¼:%.4f]",
					symbol, oiValueInMillions, minOIThresholdMillions, data.OpenInterest.Latest, data.CurrentPrice)
				continue
			}
		}

		ctx.MarketDataMap[symbol] = data
	}

	// åŠ è½½OI Topæ•°æ®ï¼ˆä¸å½±å“ä¸»æµç¨‹ï¼‰
	oiPositions, err := pool.GetOITopPositions()
	if err == nil {
		for _, pos := range oiPositions {
			// æ ‡å‡†åŒ–ç¬¦å·åŒ¹é…
			symbol := pos.Symbol
			ctx.OITopDataMap[symbol] = &OITopData{
				Rank:              pos.Rank,
				OIDeltaPercent:    pos.OIDeltaPercent,
				OIDeltaValue:      pos.OIDeltaValue,
				PriceDeltaPercent: pos.PriceDeltaPercent,
				NetLong:           pos.NetLong,
				NetShort:          pos.NetShort,
			}
		}
	}

	return nil
}

// calculateMaxCandidates æ ¹æ®è´¦æˆ·çŠ¶æ€è®¡ç®—éœ€è¦åˆ†æçš„å€™é€‰å¸ç§æ•°é‡
func calculateMaxCandidates(ctx *Context) int {
	// âš ï¸ é‡è¦ï¼šé™åˆ¶å€™é€‰å¸ç§æ•°é‡ï¼Œé¿å… Prompt è¿‡å¤§
	// æ ¹æ®æŒä»“æ•°é‡åŠ¨æ€è°ƒæ•´ï¼šæŒä»“è¶Šå°‘ï¼Œå¯ä»¥åˆ†ææ›´å¤šå€™é€‰å¸
	const (
		maxCandidatesWhenEmpty    = 30 // æ— æŒä»“æ—¶æœ€å¤šåˆ†æ30ä¸ªå€™é€‰å¸
		maxCandidatesWhenHolding1 = 25 // æŒä»“1ä¸ªæ—¶æœ€å¤šåˆ†æ25ä¸ªå€™é€‰å¸
		maxCandidatesWhenHolding2 = 20 // æŒä»“2ä¸ªæ—¶æœ€å¤šåˆ†æ20ä¸ªå€™é€‰å¸
		maxCandidatesWhenHolding3 = 15 // æŒä»“3ä¸ªæ—¶æœ€å¤šåˆ†æ15ä¸ªå€™é€‰å¸ï¼ˆé¿å… Prompt è¿‡å¤§ï¼‰
	)

	positionCount := len(ctx.Positions)
	var maxCandidates int

	switch positionCount {
	case 0:
		maxCandidates = maxCandidatesWhenEmpty
	case 1:
		maxCandidates = maxCandidatesWhenHolding1
	case 2:
		maxCandidates = maxCandidatesWhenHolding2
	default: // 3+ æŒä»“
		maxCandidates = maxCandidatesWhenHolding3
	}

	// è¿”å›å®é™…å€™é€‰å¸æ•°é‡å’Œä¸Šé™ä¸­çš„è¾ƒå°å€¼
	return min(len(ctx.CandidateCoins), maxCandidates)
}

// buildSystemPromptWithCustom æ„å»ºåŒ…å«è‡ªå®šä¹‰å†…å®¹çš„ System Prompt
func buildSystemPromptWithCustom(accountEquity, availableBalance float64, btcEthLeverage, altcoinLeverage, maxPositions int, customPrompt string, overrideBase bool, templateName string) string {
	// å¦‚æœè¦†ç›–åŸºç¡€promptä¸”æœ‰è‡ªå®šä¹‰promptï¼Œåªä½¿ç”¨è‡ªå®šä¹‰prompt
	if overrideBase && customPrompt != "" {
		return customPrompt
	}

	// è·å–åŸºç¡€promptï¼ˆä½¿ç”¨æŒ‡å®šçš„æ¨¡æ¿ï¼‰
	basePrompt := buildSystemPrompt(accountEquity, availableBalance, btcEthLeverage, altcoinLeverage, maxPositions, templateName)

	// å¦‚æœæ²¡æœ‰è‡ªå®šä¹‰promptï¼Œç›´æ¥è¿”å›åŸºç¡€prompt
	if customPrompt == "" {
		return basePrompt
	}

	// æ·»åŠ è‡ªå®šä¹‰promptéƒ¨åˆ†åˆ°åŸºç¡€prompt
	var sb strings.Builder
	sb.WriteString(basePrompt)
	sb.WriteString("\n\n")
	sb.WriteString("# ğŸ“Œ ä¸ªæ€§åŒ–äº¤æ˜“ç­–ç•¥\n\n")
	sb.WriteString(customPrompt)
	sb.WriteString("\n\n")
	sb.WriteString("æ³¨æ„: ä»¥ä¸Šä¸ªæ€§åŒ–ç­–ç•¥æ˜¯å¯¹åŸºç¡€è§„åˆ™çš„è¡¥å……ï¼Œä¸èƒ½è¿èƒŒåŸºç¡€é£é™©æ§åˆ¶åŸåˆ™ã€‚\n")

	return sb.String()
}

// buildSystemPrompt æ„å»º System Promptï¼ˆä½¿ç”¨æ¨¡æ¿+åŠ¨æ€éƒ¨åˆ†ï¼‰
func buildSystemPrompt(accountEquity, availableBalance float64, btcEthLeverage, altcoinLeverage, maxPositions int, templateName string) string {
	var sb strings.Builder

	// 1. åŠ è½½æç¤ºè¯æ¨¡æ¿ï¼ˆæ ¸å¿ƒäº¤æ˜“ç­–ç•¥éƒ¨åˆ†ï¼‰
	if templateName == "" {
		templateName = "default" // é»˜è®¤ä½¿ç”¨ default æ¨¡æ¿
	}

	template, err := GetPromptTemplate(templateName)
	if err != nil {
		// å¦‚æœæ¨¡æ¿ä¸å­˜åœ¨ï¼Œè®°å½•é”™è¯¯å¹¶ä½¿ç”¨ default
		log.Printf("âš ï¸  æç¤ºè¯æ¨¡æ¿ '%s' ä¸å­˜åœ¨ï¼Œä½¿ç”¨ default: %v", templateName, err)
		template, err = GetPromptTemplate("default")
		if err != nil {
			// å¦‚æœè¿ default éƒ½ä¸å­˜åœ¨ï¼Œä½¿ç”¨å†…ç½®çš„ç®€åŒ–ç‰ˆæœ¬
			log.Printf("âŒ æ— æ³•åŠ è½½ä»»ä½•æç¤ºè¯æ¨¡æ¿ï¼Œä½¿ç”¨å†…ç½®ç®€åŒ–ç‰ˆæœ¬")
			sb.WriteString("ä½ æ˜¯ä¸“ä¸šçš„åŠ å¯†è´§å¸äº¤æ˜“AIã€‚è¯·æ ¹æ®å¸‚åœºæ•°æ®åšå‡ºäº¤æ˜“å†³ç­–ã€‚\n\n")
		} else {
			sb.WriteString(template.Content)
			sb.WriteString("\n\n")
		}
	} else {
		sb.WriteString(template.Content)
		sb.WriteString("\n\n")
	}

	// 2. ç¡¬çº¦æŸï¼ˆé£é™©æ§åˆ¶ï¼‰- åŠ¨æ€ç”Ÿæˆ
	altcoinBasePosition := accountEquity * float64(altcoinLeverage) / float64(maxPositions)
	btcEthBasePosition := accountEquity * float64(btcEthLeverage) / float64(maxPositions)
	sb.WriteString("# ç¡¬çº¦æŸï¼ˆé£é™©æ§åˆ¶ï¼‰\n\n")
	sb.WriteString("1. é£é™©å›æŠ¥æ¯”: å¿…é¡» â‰¥ 1:3ï¼ˆå†’1%é£é™©ï¼Œèµš3%+æ”¶ç›Šï¼‰\n")
	sb.WriteString(fmt.Sprintf("2. æœ€å¤šæŒä»“: %dä¸ªå¸ç§ï¼ˆè´¨é‡>æ•°é‡ï¼‰\n", maxPositions))
	sb.WriteString(fmt.Sprintf("3. å•å¸ä»“ä½: å±±å¯¨å¸ %.0f-%.0f USD | BTC/ETH %.0f-%.0f USD\n",
		altcoinBasePosition*0.8, altcoinBasePosition, btcEthBasePosition*0.8, btcEthBasePosition))
	sb.WriteString(fmt.Sprintf("4. æ æ†é™åˆ¶: **å±±å¯¨å¸æœ€å¤§%dxæ æ†** | **BTC/ETHæœ€å¤§%dxæ æ†** (âš ï¸ ä¸¥æ ¼æ‰§è¡Œï¼Œä¸å¯è¶…è¿‡)\n", altcoinLeverage, btcEthLeverage))
	sb.WriteString(fmt.Sprintf("4. ä¿è¯é‡‘: æ€»ä½¿ç”¨ç‡ â‰¤ 90%% | å½“å‰ä½™é¢: %.2f\n\n", availableBalance))
	sb.WriteString("6. å¼€ä»“é‡‘é¢: å»ºè®® **â‰¥12 USDT** (äº¤æ˜“æ‰€æœ€å°åä¹‰ä»·å€¼ 10 USDT + å®‰å…¨è¾¹é™…)\n\n")

	// 3. è¾“å‡ºæ ¼å¼ - åŠ¨æ€ç”Ÿæˆ
	sb.WriteString("#è¾“å‡ºæ ¼å¼\n\n")
	sb.WriteString("ç¬¬ä¸€æ­¥: æ€ç»´é“¾ï¼ˆçº¯æ–‡æœ¬ï¼‰\n")
	sb.WriteString("ç®€æ´åˆ†æä½ çš„æ€è€ƒè¿‡ç¨‹\n\n")
	sb.WriteString("ç¬¬äºŒæ­¥: JSONå†³ç­–æ•°ç»„\n\n")
	sb.WriteString("```json\n[\n")
	sb.WriteString(fmt.Sprintf("  {\"symbol\": \"BTCUSDT\", \"action\": \"open_short\", \"leverage\": %d, \"position_size_usd\": %.0f, \"stop_loss\": 97000, \"take_profit\": 91000, \"confidence\": 85, \"risk_usd\": 300, \"reasoning\": \"ä¸‹è·Œè¶‹åŠ¿+MACDæ­»å‰\"},\n", btcEthLeverage, accountEquity*5))
	sb.WriteString("  {\"symbol\": \"ETHUSDT\", \"action\": \"close_long\", \"reasoning\": \"æ­¢ç›ˆç¦»åœº\"}\n")
	sb.WriteString("]\n```\n\n")
	sb.WriteString("å­—æ®µè¯´æ˜:\n")
	sb.WriteString("- `action`: open_long | open_short | close_long | close_short | hold | wait\n")
	sb.WriteString("- `confidence`: 0-100ï¼ˆå¼€ä»“å»ºè®®â‰¥75ï¼‰\n")
	sb.WriteString("- å¼€ä»“æ—¶å¿…å¡«: leverage, position_size_usd, stop_loss, take_profit, confidence, risk_usd, reasoning\n\n")

	return sb.String()
}

// buildUserPrompt æ„å»º User Promptï¼ˆåŠ¨æ€æ•°æ®ï¼‰
func buildUserPrompt(ctx *Context) string {
	var sb strings.Builder

	// ç³»ç»ŸçŠ¶æ€
	sb.WriteString(fmt.Sprintf("æ—¶é—´: %s | å‘¨æœŸ: #%d | è¿è¡Œ: %dåˆ†é’Ÿ\n\n",
		ctx.CurrentTime, ctx.CallCount, ctx.RuntimeMinutes))

	// BTC å¸‚åœº
	if btcData, hasBTC := ctx.MarketDataMap["BTCUSDT"]; hasBTC {
		sb.WriteString(fmt.Sprintf("BTC: %.2f (1h: %+.2f%%, 4h: %+.2f%%) | MACD: %.4f | RSI: %.2f\n\n",
			btcData.CurrentPrice, btcData.PriceChange1h, btcData.PriceChange4h,
			btcData.CurrentMACD, btcData.CurrentRSI7))
	}

	// è´¦æˆ·
	sb.WriteString(fmt.Sprintf("è´¦æˆ·: å‡€å€¼%.2f | ä½™é¢%.2f (%.1f%%) | ç›ˆäº%+.2f%% | ä¿è¯é‡‘%.1f%% | æŒä»“%dä¸ª\n\n",
		ctx.Account.TotalEquity,
		ctx.Account.AvailableBalance,
		(ctx.Account.AvailableBalance/ctx.Account.TotalEquity)*100,
		ctx.Account.TotalPnLPct,
		ctx.Account.MarginUsedPct,
		ctx.Account.PositionCount))

	// æŒä»“ï¼ˆå®Œæ•´å¸‚åœºæ•°æ®ï¼‰
	currentPositionKeys := make(map[string]bool)
	if len(ctx.Positions) > 0 {
		sb.WriteString("## å½“å‰æŒä»“\n")
		for i, pos := range ctx.Positions {
			// è®¡ç®—æŒä»“æ—¶é•¿
			holdingDuration := ""
			if pos.UpdateTime > 0 {
				durationMs := time.Now().UnixMilli() - pos.UpdateTime
				durationMin := durationMs / (1000 * 60) // è½¬æ¢ä¸ºåˆ†é’Ÿ
				if durationMin < 60 {
					holdingDuration = fmt.Sprintf(" | æŒä»“æ—¶é•¿%dåˆ†é’Ÿ", durationMin)
				} else {
					durationHour := durationMin / 60
					durationMinRemainder := durationMin % 60
					holdingDuration = fmt.Sprintf(" | æŒä»“æ—¶é•¿%då°æ—¶%dåˆ†é’Ÿ", durationHour, durationMinRemainder)
				}
			}

			sb.WriteString(fmt.Sprintf("%d. %s %s | å…¥åœºä»·%.4f å½“å‰ä»·%.4f | ç›ˆäº%+.2f%% | æ æ†%dx | ä¿è¯é‡‘%.0f | å¼ºå¹³ä»·%.4f%s\n\n",
				i+1, pos.Symbol, strings.ToUpper(pos.Side),
				pos.EntryPrice, pos.MarkPrice, pos.UnrealizedPnLPct,
				pos.Leverage, pos.MarginUsed, pos.LiquidationPrice, holdingDuration))

			// ä½¿ç”¨FormatMarketDataè¾“å‡ºå®Œæ•´å¸‚åœºæ•°æ®
			if marketData, ok := ctx.MarketDataMap[pos.Symbol]; ok {
				sb.WriteString(market.Format(marketData))
				sb.WriteString("\n")
			}
			currentPositionKeys[pos.Symbol] = true
		}
	} else {
		sb.WriteString("å½“å‰æŒä»“: æ— \n\n")
	}

	// å€™é€‰å¸ç§ï¼ˆå®Œæ•´å¸‚åœºæ•°æ®ï¼‰
	sb.WriteString("## å…¶ä»–å€™é€‰å¸ç§\n\n")
	displayedCount := 0
	for _, coin := range ctx.CandidateCoins {
		if currentPositionKeys[coin.Symbol] {
			continue
		}
		marketData, hasData := ctx.MarketDataMap[coin.Symbol]
		if !hasData {
			continue
		}
		displayedCount++

		sourceTags := ""
		if len(coin.Sources) > 1 {
			sourceTags = " (AI500+OI_TopåŒé‡ä¿¡å·)"
		} else if len(coin.Sources) == 1 && coin.Sources[0] == "oi_top" {
			sourceTags = " (OI_TopæŒä»“å¢é•¿)"
		}

		// ä½¿ç”¨FormatMarketDataè¾“å‡ºå®Œæ•´å¸‚åœºæ•°æ®
		sb.WriteString(fmt.Sprintf("### %d. %s%s\n\n", displayedCount, coin.Symbol, sourceTags))
		sb.WriteString(market.Format(marketData))
		sb.WriteString("\n")
	}
	sb.WriteString("\n")

	// å¤æ™®æ¯”ç‡ï¼ˆç›´æ¥ä¼ å€¼ï¼Œä¸è¦å¤æ‚æ ¼å¼åŒ–ï¼‰
	if ctx.Performance != nil {
		// ç›´æ¥ä»interface{}ä¸­æå–SharpeRatio
		type PerformanceData struct {
			SharpeRatio float64 `json:"sharpe_ratio"`
		}
		var perfData PerformanceData
		if jsonData, err := json.Marshal(ctx.Performance); err == nil {
			if err := json.Unmarshal(jsonData, &perfData); err == nil {
				sb.WriteString(fmt.Sprintf("## ğŸ“Š å¤æ™®æ¯”ç‡: %.2f\n\n", perfData.SharpeRatio))
			}
		}
	}

	sb.WriteString("---\n\n")
	sb.WriteString("ç°åœ¨è¯·åˆ†æå¹¶è¾“å‡ºå†³ç­–ï¼ˆæ€ç»´é“¾ + JSONï¼‰\n")

	return sb.String()
}

// parseFullDecisionResponse è§£æAIçš„å®Œæ•´å†³ç­–å“åº”
func parseFullDecisionResponse(aiResponse string, ctx *Context) (*FullDecision, error) {
	// 1. æå–æ€ç»´é“¾
	cotTrace := extractCoTTrace(aiResponse)

	// 2. æå–JSONå†³ç­–åˆ—è¡¨
	decisions, err := extractDecisions(aiResponse)
	if err != nil {
		return &FullDecision{
			CoTTrace:  cotTrace,
			Decisions: []Decision{},
		}, fmt.Errorf("æå–å†³ç­–å¤±è´¥: %w", err)
	}

	// 3. å¯¹å†³ç­–æ’åºï¼šç¡®ä¿å…ˆå¹³ä»“åå¼€ä»“ï¼ˆé˜²æ­¢ä»“ä½å åŠ è¶…é™ï¼‰
	decisions = sortDecisionsByPriority(decisions)

	// 4. éªŒè¯å†³ç­–
	decisions, err = validateDecisions(decisions, ctx)

	return &FullDecision{
		CoTTrace:  cotTrace,
		Decisions: decisions,
	}, err
}

// extractCoTTrace æå–æ€ç»´é“¾åˆ†æ
func extractCoTTrace(response string) string {
	// æŸ¥æ‰¾JSONæ•°ç»„çš„å¼€å§‹ä½ç½®
	jsonStart := strings.Index(response, "[")

	if jsonStart > 0 {
		// æ€ç»´é“¾æ˜¯JSONæ•°ç»„ä¹‹å‰çš„å†…å®¹
		return strings.TrimSpace(response[:jsonStart])
	}

	// å¦‚æœæ‰¾ä¸åˆ°JSONï¼Œæ•´ä¸ªå“åº”éƒ½æ˜¯æ€ç»´é“¾
	return strings.TrimSpace(response)
}

// extractDecisions æå–JSONå†³ç­–åˆ—è¡¨
func extractDecisions(response string) ([]Decision, error) {
	// é¢„æ¸…æ´—ï¼šå»é›¶å®½/BOM
	s := removeInvisibleRunes(response)
	s = strings.TrimSpace(s)

	// ğŸ”§ é—œéµä¿®å¾©ï¼šåœ¨æ­£å‰‡åŒ¹é…ä¹‹å‰å°±å…ˆä¿®å¾©å…¨è§’å­—ç¬¦ï¼
	// å¦å‰‡æ­£å‰‡è¡¨é”å¼ \[ ç„¡æ³•åŒ¹é…å…¨è§’çš„ ï¼»
	s = fixMissingQuotes(s)

	// 1) ä¼˜å…ˆä» ```json ä»£ç å—ä¸­æå–
	if m := reJSONFence.FindStringSubmatch(s); len(m) > 1 {
		jsonContent := strings.TrimSpace(m[1])
		jsonContent = compactArrayOpen(jsonContent) // æŠŠ "[ {" è§„æ•´ä¸º "[{"
		jsonContent = fixMissingQuotes(jsonContent) // äºŒæ¬¡ä¿®å¾©ï¼ˆé˜²æ­¢ regex æå–å¾Œé‚„æœ‰å…¨è§’ï¼‰
		if err := validateJSONFormat(jsonContent); err != nil {
			return nil, fmt.Errorf("JSONæ ¼å¼éªŒè¯å¤±è´¥: %w\nJSONå†…å®¹: %s\nå®Œæ•´å“åº”:\n%s", err, jsonContent, response)
		}
		var decisions []Decision
		if err := json.Unmarshal([]byte(jsonContent), &decisions); err != nil {
			return nil, fmt.Errorf("JSONè§£æå¤±è´¥: %w\nJSONå†…å®¹: %s", err, jsonContent)
		}
		return decisions, nil
	}

	// 2) é€€è€Œæ±‚å…¶æ¬¡ï¼šå…¨æ–‡å¯»æ‰¾é¦–ä¸ªå¯¹è±¡æ•°ç»„
	// æ³¨æ„ï¼šæ­¤æ™‚ s å·²ç¶“é fixMissingQuotes()ï¼Œå…¨è§’å­—ç¬¦å·²è½‰æ›ç‚ºåŠè§’
	jsonContent := strings.TrimSpace(reJSONArray.FindString(s))
	if jsonContent == "" {
		return nil, fmt.Errorf("æ— æ³•æ‰¾åˆ°JSONæ•°ç»„èµ·å§‹ï¼ˆå·²å˜—è©¦ä¿®å¾©å…¨è§’å­—ç¬¦ï¼‰\nåŸå§‹éŸ¿æ‡‰å‰200å­—ç¬¦: %s", s[:min(200, len(s))])
	}

	// ğŸ”§ è¦æ•´æ ¼å¼ï¼ˆæ­¤æ™‚å…¨è§’å­—ç¬¦å·²åœ¨å‰é¢ä¿®å¾©éï¼‰
	jsonContent = compactArrayOpen(jsonContent)
	jsonContent = fixMissingQuotes(jsonContent) // äºŒæ¬¡ä¿®å¾©ï¼ˆé˜²æ­¢ regex æå–å¾Œé‚„æœ‰æ®˜ç•™å…¨è§’ï¼‰

	// ğŸ”§ éªŒè¯ JSON æ ¼å¼ï¼ˆæ£€æµ‹å¸¸è§é”™è¯¯ï¼‰
	if err := validateJSONFormat(jsonContent); err != nil {
		return nil, fmt.Errorf("JSONæ ¼å¼éªŒè¯å¤±è´¥: %w\nJSONå†…å®¹: %s\nå®Œæ•´å“åº”:\n%s", err, jsonContent, response)
	}

	// è§£æJSON
	var decisions []Decision
	if err := json.Unmarshal([]byte(jsonContent), &decisions); err != nil {
		return nil, fmt.Errorf("JSONè§£æå¤±è´¥: %w\nJSONå†…å®¹: %s", err, jsonContent)
	}

	return decisions, nil
}

// fixMissingQuotes æ›¿æ¢ä¸­æ–‡å¼•å·å’Œå…¨è§’å­—ç¬¦ä¸ºè‹±æ–‡å¼•å·å’ŒåŠè§’å­—ç¬¦ï¼ˆé¿å…AIè¾“å‡ºå…¨è§’JSONå­—ç¬¦å¯¼è‡´è§£æå¤±è´¥ï¼‰
func fixMissingQuotes(jsonStr string) string {
	// æ›¿æ¢ä¸­æ–‡å¼•å·
	jsonStr = strings.ReplaceAll(jsonStr, "\u201c", "\"") // "
	jsonStr = strings.ReplaceAll(jsonStr, "\u201d", "\"") // "
	jsonStr = strings.ReplaceAll(jsonStr, "\u2018", "'")  // '
	jsonStr = strings.ReplaceAll(jsonStr, "\u2019", "'")  // '

	// âš ï¸ æ›¿æ¢å…¨è§’æ‹¬å·ã€å†’å·ã€é€—å·ï¼ˆé˜²æ­¢AIè¾“å‡ºå…¨è§’JSONå­—ç¬¦ï¼‰
	jsonStr = strings.ReplaceAll(jsonStr, "ï¼»", "[") // U+FF3B å…¨è§’å·¦æ–¹æ‹¬å·
	jsonStr = strings.ReplaceAll(jsonStr, "ï¼½", "]") // U+FF3D å…¨è§’å³æ–¹æ‹¬å·
	jsonStr = strings.ReplaceAll(jsonStr, "ï½›", "{") // U+FF5B å…¨è§’å·¦èŠ±æ‹¬å·
	jsonStr = strings.ReplaceAll(jsonStr, "ï½", "}") // U+FF5D å…¨è§’å³èŠ±æ‹¬å·
	jsonStr = strings.ReplaceAll(jsonStr, "ï¼š", ":") // U+FF1A å…¨è§’å†’å·
	jsonStr = strings.ReplaceAll(jsonStr, "ï¼Œ", ",") // U+FF0C å…¨è§’é€—å·

	// âš ï¸ æ›¿æ¢CJKæ ‡ç‚¹ç¬¦å·ï¼ˆAIåœ¨ä¸­æ–‡ä¸Šä¸‹æ–‡ä¸­ä¹Ÿå¯èƒ½è¾“å‡ºè¿™äº›ï¼‰
	jsonStr = strings.ReplaceAll(jsonStr, "ã€", "[") // CJKå·¦æ–¹å¤´æ‹¬å· U+3010
	jsonStr = strings.ReplaceAll(jsonStr, "ã€‘", "]") // CJKå³æ–¹å¤´æ‹¬å· U+3011
	jsonStr = strings.ReplaceAll(jsonStr, "ã€”", "[") // CJKå·¦é¾Ÿå£³æ‹¬å· U+3014
	jsonStr = strings.ReplaceAll(jsonStr, "ã€•", "]") // CJKå³é¾Ÿå£³æ‹¬å· U+3015
	jsonStr = strings.ReplaceAll(jsonStr, "ã€", ",") // CJKé¡¿å· U+3001

	// âš ï¸ æ›¿æ¢å…¨è§’ç©ºæ ¼ä¸ºåŠè§’ç©ºæ ¼ï¼ˆJSONä¸­ä¸åº”è¯¥æœ‰å…¨è§’ç©ºæ ¼ï¼‰
	jsonStr = strings.ReplaceAll(jsonStr, "ã€€", " ") // U+3000 å…¨è§’ç©ºæ ¼

	return jsonStr
}

// validateJSONFormat éªŒè¯ JSON æ ¼å¼ï¼Œæ£€æµ‹å¸¸è§é”™è¯¯
func validateJSONFormat(jsonStr string) error {
	trimmed := strings.TrimSpace(jsonStr)

	// å…è®¸ [ å’Œ { ä¹‹é—´å­˜åœ¨ä»»æ„ç©ºç™½ï¼ˆå«é›¶å®½ï¼‰
	if !reArrayHead.MatchString(trimmed) {
		// æ£€æŸ¥æ˜¯å¦æ˜¯çº¯æ•°å­—/èŒƒå›´æ•°ç»„ï¼ˆå¸¸è§é”™è¯¯ï¼‰
		if strings.HasPrefix(trimmed, "[") && !strings.Contains(trimmed[:min(20, len(trimmed))], "{") {
			return fmt.Errorf("ä¸æ˜¯æœ‰æ•ˆçš„å†³ç­–æ•°ç»„ï¼ˆå¿…é¡»åŒ…å«å¯¹è±¡ {}ï¼‰ï¼Œå®é™…å†…å®¹: %s", trimmed[:min(50, len(trimmed))])
		}
		return fmt.Errorf("JSON å¿…é¡»ä»¥ [{ å¼€å¤´ï¼ˆå…è®¸ç©ºç™½ï¼‰ï¼Œå®é™…: %s", trimmed[:min(20, len(trimmed))])
	}

	// æ£€æŸ¥æ˜¯å¦åŒ…å«èŒƒå›´ç¬¦å· ~ï¼ˆLLM å¸¸è§é”™è¯¯ï¼‰
	if strings.Contains(jsonStr, "~") {
		return fmt.Errorf("JSON ä¸­ä¸å¯åŒ…å«èŒƒå›´ç¬¦å· ~ï¼Œæ‰€æœ‰æ•°å­—å¿…é¡»æ˜¯ç²¾ç¡®çš„å•ä¸€å€¼")
	}

	// æ£€æŸ¥æ˜¯å¦åŒ…å«åƒä½åˆ†éš”ç¬¦ï¼ˆå¦‚ 98,000ï¼‰
	// ä½¿ç”¨ç®€å•çš„æ¨¡å¼åŒ¹é…ï¼šæ•°å­—+é€—å·+3ä½æ•°å­—
	for i := 0; i < len(jsonStr)-4; i++ {
		if jsonStr[i] >= '0' && jsonStr[i] <= '9' &&
			jsonStr[i+1] == ',' &&
			jsonStr[i+2] >= '0' && jsonStr[i+2] <= '9' &&
			jsonStr[i+3] >= '0' && jsonStr[i+3] <= '9' &&
			jsonStr[i+4] >= '0' && jsonStr[i+4] <= '9' {
			return fmt.Errorf("JSON æ•°å­—ä¸å¯åŒ…å«åƒä½åˆ†éš”ç¬¦é€—å·ï¼Œå‘ç°: %s", jsonStr[i:min(i+10, len(jsonStr))])
		}
	}

	return nil
}

// min è¿”å›ä¸¤ä¸ªæ•´æ•°ä¸­çš„è¾ƒå°å€¼
func min(a, b int) int {
	if a < b {
		return a
	}
	return b
}

// removeInvisibleRunes å»é™¤é›¶å®½å­—ç¬¦å’Œ BOMï¼Œé¿å…è‚‰çœ¼çœ‹ä¸è§çš„å‰ç¼€ç ´åæ ¡éªŒ
func removeInvisibleRunes(s string) string {
	return reInvisibleRunes.ReplaceAllString(s, "")
}

// compactArrayOpen è§„æ•´å¼€å¤´çš„ "[ {" â†’ "[{"
func compactArrayOpen(s string) string {
	return reArrayOpenSpace.ReplaceAllString(strings.TrimSpace(s), "[{")
}

// validateDecisions éªŒè¯æ‰€æœ‰å†³ç­–ï¼ˆéœ€è¦è´¦æˆ·ä¿¡æ¯å’Œæ æ†é…ç½®ï¼‰
func validateDecisions(decisions []Decision, ctx *Context) ([]Decision, error) {
	btcEthLeverage := ctx.BTCETHLeverage
	altcoinLeverage := ctx.AltcoinLeverage
	availableBalance := ctx.Account.AvailableBalance
	var filteredDecisions []Decision
	var errorMsgs []string
	for _, decision := range decisions {
		positions := getPositionsOfSpecificSymbol(ctx.Positions, decision.Symbol)
		if err := validateDecision(&decision, availableBalance, btcEthLeverage, altcoinLeverage, positions, ctx.MarketDataMap[decision.Symbol]); err != nil {
			errorMsgs = append(errorMsgs, err.Error())
		} else {
			filteredDecisions = append(filteredDecisions, decision)
			if decision.Action == "open_long" || decision.Action == "open_short" {
				availableBalance -= decision.PositionSizeUSD / float64(decision.Leverage)
			} else if decision.Action == "close_long" || decision.Action == "close_short" {
				availableBalance += positions[0].MarginUsed
			}
		}
	}

	if len(errorMsgs) > 0 {
		combinedErr := fmt.Errorf("å†³ç­–éªŒè¯å¤±è´¥: %s", strings.Join(errorMsgs, "; "))
		return filteredDecisions, combinedErr
	}

	return filteredDecisions, nil
}

func getPositionsOfSpecificSymbol(positions []PositionInfo, symbol string) []PositionInfo {
	var filteredPositions []PositionInfo
	for _, position := range positions {
		if position.Symbol == symbol {
			filteredPositions = append(filteredPositions, position)
		}
	}

	if len(filteredPositions) > 1 {
		panic(symbol + "å­˜åœ¨>1ä¸ªä»“ä½")
	}

	return filteredPositions
}

// findMatchingBracket æŸ¥æ‰¾åŒ¹é…çš„å³æ‹¬å·
func findMatchingBracket(s string, start int) int {
	if start >= len(s) || s[start] != '[' {
		return -1
	}

	depth := 0
	for i := start; i < len(s); i++ {
		switch s[i] {
		case '[':
			depth++
		case ']':
			depth--
			if depth == 0 {
				return i
			}
		}
	}

	return -1
}

// validateDecision éªŒè¯å•ä¸ªå†³ç­–çš„æœ‰æ•ˆæ€§
func validateDecision(d *Decision, availableBalance float64, btcEthLeverage, altcoinLeverage int, positions []PositionInfo, marketData *market.Data) error {
	// éªŒè¯action
	validActions := map[string]bool{
		"open_long":          true,
		"open_short":         true,
		"close_long":         true,
		"close_short":        true,
		"update_stop_loss":   true,
		"update_take_profit": true,
		"partial_close":      true,
		"hold":               true,
		"wait":               true,
	}

	if !validActions[d.Action] {
		return fmt.Errorf("æ— æ•ˆçš„action: %s", d.Action)
	}

	if d.Action == "close_long" || d.Action == "close_short" {
		if len(positions) == 0 {
			return fmt.Errorf("%sä¸å­˜åœ¨ä»“ä½", d.Symbol)
		}
		if (d.Action == "close_long" && positions[0].Side != "long") || (d.Action == "close_short" && positions[0].Side != "short") {
			return fmt.Errorf("AIçš„å†³ç­–æ˜¯%sï¼Œä½†å½“å‰æŒä»“ä¸º%s", d.Action, positions[0].Side)
		}
	}

	// å¼€ä»“æ“ä½œå¿…é¡»æä¾›å®Œæ•´å‚æ•°
	if d.Action == "open_long" || d.Action == "open_short" {
		if len(positions) > 0 {
			return fmt.Errorf("%så·²å­˜åœ¨ä»“ä½", d.Symbol)
		}

		// æ ¹æ®å¸ç§ä½¿ç”¨é…ç½®çš„æ æ†ä¸Šé™
		maxLeverage := altcoinLeverage                             // å±±å¯¨å¸ä½¿ç”¨é…ç½®çš„æ æ†
		maxPositionValue := availableBalance * float64(d.Leverage) // å±±å¯¨å¸ä»“ä½
		if d.Symbol == "BTCUSDT" || d.Symbol == "ETHUSDT" {
			maxLeverage = btcEthLeverage                              // BTC/ETHä½¿ç”¨é…ç½®çš„æ æ†
			maxPositionValue = availableBalance * float64(d.Leverage) // BTC/ETHä»“ä½
		}

		if d.Leverage <= 0 || d.Leverage > maxLeverage {
			return fmt.Errorf("æ æ†å¿…é¡»åœ¨0-%dä¹‹é—´ï¼ˆ%sï¼Œå½“å‰é…ç½®ä¸Šé™%då€ï¼‰: %d", maxLeverage, d.Symbol, maxLeverage, d.Leverage)
		}
		if d.PositionSizeUSD <= 0 {
			return fmt.Errorf("ä»“ä½å¤§å°å¿…é¡»å¤§äº0: %.2f", d.PositionSizeUSD)
		}

		// âœ… éªŒè¯æœ€å°å¼€ä»“é‡‘é¢ï¼ˆé˜²æ­¢æ•°é‡æ ¼å¼åŒ–ä¸º 0 çš„é”™è¯¯ï¼‰
		// Binance æœ€å°åä¹‰ä»·å€¼ 10 USDT + å®‰å…¨è¾¹é™…
		const minPositionSizeGeneral = 12.0 // 10 + 20% å®‰å…¨è¾¹é™…
		const minPositionSizeBTCETH = 60.0  // BTC/ETH å› ä»·æ ¼é«˜å’Œç²¾åº¦é™åˆ¶éœ€è¦æ›´å¤§é‡‘é¢ï¼ˆæ›´çµæ´»ï¼‰

		if d.Symbol == "BTCUSDT" || d.Symbol == "ETHUSDT" {
			if d.PositionSizeUSD < minPositionSizeBTCETH {
				return fmt.Errorf("%s å¼€ä»“é‡‘é¢è¿‡å°(%.2f USDT)ï¼Œå¿…é¡»â‰¥%.2f USDTï¼ˆå› ä»·æ ¼é«˜ä¸”ç²¾åº¦é™åˆ¶ï¼Œé¿å…æ•°é‡å››èˆäº”å…¥ä¸º0ï¼‰", d.Symbol, d.PositionSizeUSD, minPositionSizeBTCETH)
			}
		} else {
			if d.PositionSizeUSD < minPositionSizeGeneral {
				return fmt.Errorf("å¼€ä»“é‡‘é¢è¿‡å°(%.2f USDT)ï¼Œå¿…é¡»â‰¥%.2f USDTï¼ˆBinance æœ€å°åä¹‰ä»·å€¼è¦æ±‚ï¼‰", d.PositionSizeUSD, minPositionSizeGeneral)
			}
		}

		// éªŒè¯ä»“ä½ä»·å€¼ä¸Šé™ï¼ˆåŠ 1%å®¹å·®ä»¥é¿å…æµ®ç‚¹æ•°ç²¾åº¦é—®é¢˜ï¼‰
		if d.PositionSizeUSD > maxPositionValue*0.99 {
			if d.Symbol == "BTCUSDT" || d.Symbol == "ETHUSDT" {
				return fmt.Errorf("BTC/ETHå•å¸ç§ä»“ä½ä»·å€¼ä¸èƒ½è¶…è¿‡%.0f USDï¼Œå®é™…: %.0f", maxPositionValue, d.PositionSizeUSD)
			} else {
				return fmt.Errorf("å±±å¯¨å¸å•å¸ç§ä»“ä½ä»·å€¼ä¸èƒ½è¶…è¿‡%.0f USDï¼Œå®é™…: %.0f", maxPositionValue, d.PositionSizeUSD)
			}
		}
		if d.StopLoss <= 0 || d.TakeProfit <= 0 {
			return fmt.Errorf("æ­¢æŸå’Œæ­¢ç›ˆå¿…é¡»å¤§äº0")
		}

		// è®¡ç®—å…¥åœºä»·ï¼ˆå‡è®¾å½“å‰å¸‚ä»·ï¼‰
		entryPrice := marketData.CurrentPrice

		// éªŒè¯æ­¢æŸæ­¢ç›ˆçš„åˆç†æ€§
		if d.Action == "open_long" {
			if d.StopLoss >= entryPrice || d.TakeProfit <= entryPrice {
				return fmt.Errorf("åšå¤šæ—¶æ­¢æŸä»·å¿…é¡»å°äºå¼€å•ä»·ï¼Œæ­¢ç›ˆä»·å¿…é¡»å¤§äºå¼€å•ä»·")
			}
		} else {
			if d.StopLoss <= entryPrice || d.TakeProfit >= entryPrice {
				return fmt.Errorf("åšç©ºæ—¶æ­¢æŸä»·å¿…é¡»å¤§äºå¼€å•ä»·ï¼Œæ­¢ç›ˆä»·å¿…é¡»å°äºå¼€å•ä»·")
			}
		}

		// éªŒè¯é£é™©å›æŠ¥æ¯”ï¼ˆå¿…é¡»â‰¥1:3ï¼‰
		var riskPercent, rewardPercent, riskRewardRatio float64
		if d.Action == "open_long" {
			riskPercent = (entryPrice - d.StopLoss) / entryPrice * 100
			rewardPercent = (d.TakeProfit - entryPrice) / entryPrice * 100
			if riskPercent > 0 {
				riskRewardRatio = rewardPercent / riskPercent
			}
		} else {
			riskPercent = (d.StopLoss - entryPrice) / entryPrice * 100
			rewardPercent = (entryPrice - d.TakeProfit) / entryPrice * 100
			if riskPercent > 0 {
				riskRewardRatio = rewardPercent / riskPercent
			}
		}

		// ç¡¬çº¦æŸï¼šé£é™©å›æŠ¥æ¯”å¿…é¡»â‰¥3.0
		if riskRewardRatio < 3.0 {
			return fmt.Errorf("é£é™©å›æŠ¥æ¯”è¿‡ä½(%.2f:1)ï¼Œå¿…é¡»â‰¥3.0:1 [é£é™©:%.2f%% æ”¶ç›Š:%.2f%%] [å½“å‰ä»·:%.2f æ­¢æŸ:%.2f æ­¢ç›ˆ:%.2f]",
				riskRewardRatio, riskPercent, rewardPercent, entryPrice, d.StopLoss, d.TakeProfit)
		}
	}

	// åŠ¨æ€è°ƒæ•´æ­¢æŸéªŒè¯
	if d.Action == "update_stop_loss" {
		if d.NewStopLoss <= 0 {
			return fmt.Errorf("æ–°æ­¢æŸä»·æ ¼å¿…é¡»å¤§äº0: %.2f", d.NewStopLoss)
		}
	}

	// åŠ¨æ€è°ƒæ•´æ­¢ç›ˆéªŒè¯
	if d.Action == "update_take_profit" {
		if d.NewTakeProfit <= 0 {
			return fmt.Errorf("æ–°æ­¢ç›ˆä»·æ ¼å¿…é¡»å¤§äº0: %.2f", d.NewTakeProfit)
		}
	}

	// éƒ¨åˆ†å¹³ä»“éªŒè¯
	if d.Action == "partial_close" {
		if d.ClosePercentage <= 0 || d.ClosePercentage > 100 {
			return fmt.Errorf("å¹³ä»“ç™¾åˆ†æ¯”å¿…é¡»åœ¨0-100ä¹‹é—´: %.1f", d.ClosePercentage)
		}
	}

	return nil
}

// sortDecisionsByPriority å¯¹å†³ç­–æ’åºï¼šå…ˆå¹³ä»“ï¼Œå†å¼€ä»“ï¼Œæœ€åhold/wait
// è¿™æ ·å¯ä»¥é¿å…æ¢ä»“æ—¶ä»“ä½å åŠ è¶…é™
func sortDecisionsByPriority(decisions []Decision) []Decision {
	if len(decisions) <= 1 {
		return decisions
	}

	// å®šä¹‰ä¼˜å…ˆçº§
	getActionPriority := func(action string) int {
		switch action {
		case "close_long", "close_short":
			return 1 // æœ€é«˜ä¼˜å…ˆçº§ï¼šå…ˆå¹³ä»“
		case "open_long", "open_short":
			return 2 // æ¬¡ä¼˜å…ˆçº§ï¼šåå¼€ä»“
		case "hold", "wait":
			return 3 // æœ€ä½ä¼˜å…ˆçº§ï¼šè§‚æœ›
		default:
			return 999 // æœªçŸ¥åŠ¨ä½œæ”¾æœ€å
		}
	}

	// å¤åˆ¶å†³ç­–åˆ—è¡¨
	sorted := make([]Decision, len(decisions))
	copy(sorted, decisions)

	// æŒ‰ä¼˜å…ˆçº§æ’åº
	for i := 0; i < len(sorted)-1; i++ {
		for j := i + 1; j < len(sorted); j++ {
			if getActionPriority(sorted[i].Action) > getActionPriority(sorted[j].Action) {
				sorted[i], sorted[j] = sorted[j], sorted[i]
			}
		}
	}

	return sorted
}
